// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package build

import (
	"go-slim/api/admin/controllers"
	"go-slim/api/admin/routes"
	services2 "go-slim/api/admin/services"
	"go-slim/api/server/controllers/v1"
	"go-slim/api/server/controllers/v2"
	"go-slim/api/server/controllers/v2/auth"
	"go-slim/api/server/controllers/v2/open"
	"go-slim/api/server/controllers/v2/server"
	"go-slim/api/server/controllers/v2/upload"
	"go-slim/api/server/controllers/v2/verify"
	"go-slim/api/server/logic"
	"go-slim/api/server/middlewares"
	routes2 "go-slim/api/server/routes"
	"go-slim/api/server/services/file_upload"
	"go-slim/api/server/services/sign_checker"
	"go-slim/internal/config"
	"go-slim/internal/cron"
	"go-slim/internal/queue"
	routes3 "go-slim/internal/routes"
	"go-slim/internal/services"
	"go-slim/pkg/xaliyun"
	"go-slim/pkg/xbaidu"
	"go-slim/pkg/xcaptcha"
	"go-slim/pkg/xcrypt"
	"go-slim/pkg/xhttp"
	"go-slim/pkg/xjwt"
	"go-slim/pkg/xlimiter"
	"go-slim/pkg/xlog"
	"go-slim/pkg/xmysql"
	"go-slim/pkg/xoptimus"
	"go-slim/pkg/xoss"
	"go-slim/pkg/xpaddle"
	"go-slim/pkg/xredis"
	"go-slim/pkg/xsnowflake"
	"go-slim/pkg/xtencent"
	"go-slim/web/home"
	controllers2 "go-slim/web/home/controllers"
	"go-slim/web/static"
	sign_checker2 "go-slim/web/static/services/sign_checker"
)

// Injectors from wire.go:

func BuildApp(cfg *config.Config) (*App, error) {
	xhttpConfig := cfg.Http
	engine := xhttp.NewGin(xhttpConfig)
	httpServer := xhttp.NewHttp(xhttpConfig, engine)
	http := &xhttp.Http{
		Server: httpServer,
	}
	xlogConfig := cfg.Log
	appConfig := cfg.App
	logger := xlog.NewLogger(xlogConfig, appConfig)
	manager := xlog.NewManager(xlogConfig, appConfig)
	xmysqlConfig := cfg.Mysql
	db := xmysql.NewMysql(xmysqlConfig, manager)
	xredisConfig := cfg.Redis
	client := xredis.NewRedis(xredisConfig)
	stringCaptcha := xcaptcha.NewStringCaptcha(client)
	xjwtConfig := cfg.JWT
	idToken := xjwt.NewToken(xjwtConfig)
	authController := &controllers.AuthController{
		DB:            db,
		StringCaptcha: stringCaptcha,
		JWT:           idToken,
		Cfg:           appConfig,
	}
	adminUserController := &controllers.AdminUserController{
		DB: db,
	}
	adminDepartmentController := &controllers.AdminDepartmentController{
		DB: db,
	}
	articleContentController := &controllers.ArticleContentController{
		DB: db,
	}
	articleCategoryController := &controllers.ArticleCategoryController{
		DB: db,
	}
	urlGen := services.NewUrlGen(appConfig)
	xsnowflakeConfig := cfg.SnowFlake
	snowFlake := xsnowflake.NewSnowFlake(xsnowflakeConfig)
	formFile := &services2.FormFile{
		Global:    appConfig,
		SnowFlake: snowFlake,
	}
	serverController := &controllers.ServerController{
		UrlGen:   urlGen,
		FormFile: formFile,
		DB:       db,
	}
	routesControllers := &routes.Controllers{
		Auth:            authController,
		AdminUser:       adminUserController,
		AdminDepartment: adminDepartmentController,
		ArticleContent:  articleContentController,
		ArticleCategory: articleCategoryController,
		Server:          serverController,
	}
	apiAdminRoute := &routes.ApiAdminRoute{
		Gin: engine,
		Ctl: routesControllers,
		JWT: idToken,
	}
	serverServer := &server.Server{
		Redis: client,
		Mysql: db,
	}
	v1Controllers := &v1.Controllers{
		Server: serverServer,
	}
	apiV1Route := &routes2.ApiV1Route{
		Gin: engine,
		Ctl: v1Controllers,
	}
	file_uploadFormFile := &file_upload.FormFile{
		Global:    appConfig,
		SnowFlake: snowFlake,
	}
	formData := &file_upload.FormData{}
	xcryptConfig := cfg.Crypt
	aesCbc := xcrypt.NewAesCbc(xcryptConfig)
	rangeFile := &upload.RangeFile{
		FormFile: file_uploadFormFile,
		FormData: formData,
		Mysql:    db,
		AesCbc:   aesCbc,
	}
	singleFile := &upload.SingleFile{
		Mysql:    db,
		FormFile: file_uploadFormFile,
	}
	rules := &upload.Rules{}
	check := &upload.Check{
		AesCbc: aesCbc,
	}
	xpaddleConfig := cfg.Paddle
	xpaddleClient := xpaddle.NewClient(xpaddleConfig)
	humansegMobileClient := &xpaddle.HumansegMobileClient{
		Client: xpaddleClient,
	}
	paddle := &open.Paddle{
		Humanseg: humansegMobileClient,
	}
	xaliyunConfig := cfg.Aliyun
	clientConfig := xaliyun.NewOpenApiConfig(xaliyunConfig)
	imageSeg := xaliyun.NewImageSeg(clientConfig)
	xossConfig := cfg.Oss
	ossClient, err := xoss.NewClient(xossConfig)
	if err != nil {
		return nil, err
	}
	bucket, err := xoss.NewBucket(ossClient, xossConfig)
	if err != nil {
		return nil, err
	}
	aliyun := &open.Aliyun{
		Seg: imageSeg,
		Oss: bucket,
	}
	xbaiduConfig := cfg.Baidu
	oauth := xbaidu.NewOauth(xbaiduConfig)
	xbaiduClient := xbaidu.NewClient(oauth)
	baidu := &open.Baidu{
		Client: xbaiduClient,
	}
	xtencentConfig := cfg.Tencent
	credential := xtencent.NewCredential(xtencentConfig)
	clientProfile := xtencent.NewClientProfile()
	ftClient := xtencent.NewFtClient(xtencentConfig, credential, clientProfile)
	tencent := &open.Tencent{
		Client: ftClient,
	}
	xoptimusConfig := cfg.Optimus
	optimus := xoptimus.NewOptimus(xoptimusConfig)
	userClient := &logic.UserClient{
		DB:      db,
		Optimus: optimus,
	}
	appClient := &auth.AppClient{
		DB:         db,
		JWT:        idToken,
		UserClient: userClient,
	}
	username := &auth.Username{
		DB:            db,
		JWT:           idToken,
		StringCaptcha: stringCaptcha,
	}
	captcha := &verify.Captcha{
		StringCaptcha: stringCaptcha,
	}
	v2Controllers := &v2.Controllers{
		UploadRangeFile:  rangeFile,
		UploadSingleFile: singleFile,
		UploadRule:       rules,
		UploadCheck:      check,
		Server:           serverServer,
		Paddle:           paddle,
		Aliyun:           aliyun,
		Baidu:            baidu,
		Tencent:          tencent,
		AppClient:        appClient,
		AuthUsername:     username,
		VerifyCaptcha:    captcha,
	}
	limitReachedHandler := middlewares.NewLimitReachedHandler()
	xlimiterConfig := cfg.Limiter
	limiter := xlimiter.NewLimiter(client, limitReachedHandler, xlimiterConfig)
	signChecker := sign_checker.SignChecker{
		Redis: client,
		Mysql: db,
	}
	signJsonChecker := &sign_checker.SignJsonChecker{
		SignChecker: signChecker,
	}
	apiV2Route := &routes2.ApiV2Route{
		Gin:             engine,
		Ctl:             v2Controllers,
		Limiter:         limiter,
		SignJsonChecker: signJsonChecker,
		AesCbc:          aesCbc,
	}
	sign_checkerSignChecker := sign_checker2.SignChecker{
		Redis: client,
		Mysql: db,
	}
	signUrlChecker := &sign_checker2.SignUrlChecker{
		SignChecker: sign_checkerSignChecker,
	}
	webStaticRoute := &static.WebStaticRoute{
		Gin:            engine,
		SignUrlChecker: signUrlChecker,
		Config:         cfg,
		Global:         appConfig,
	}
	controllersHome := &controllers2.Home{
		UrlGen: urlGen,
	}
	agreement := &controllers2.Agreement{}
	feedback := &controllers2.Feedback{}
	attachment := &controllers2.Attachment{
		UrlGen: urlGen,
	}
	homeControllers := &home.Controllers{
		Home:       controllersHome,
		Agreement:  agreement,
		Feedback:   feedback,
		Attachment: attachment,
	}
	webHomeRoute := &home.WebHomeRoute{
		Gin:         engine,
		Controllers: homeControllers,
		Global:      appConfig,
	}
	routesRoutes := &routes3.Routes{
		Gin:            engine,
		Config:         cfg,
		Log:            logger,
		LogManager:     manager,
		ApiAdminRoute:  apiAdminRoute,
		ApiV1Route:     apiV1Route,
		ApiV2Route:     apiV2Route,
		WebStaticRoute: webStaticRoute,
		WebHomeRoute:   webHomeRoute,
	}
	redisClientOpt := queue.GetRedisClientOpt(xredisConfig)
	queueLogger := queue.NewLogger(manager)
	asynqConfig := queue.GetConfig(queueLogger)
	demoTask := &queue.DemoTask{
		Redis: client,
	}
	tasks := &queue.Tasks{
		DemoTask: demoTask,
	}
	queueManager := &queue.Manager{
		RdsOpt: redisClientOpt,
		Conf:   asynqConfig,
		Tasks:  tasks,
	}
	cronDemoTask := &cron.DemoTask{}
	cronTasks := &cron.Tasks{
		DemoTask: cronDemoTask,
	}
	cronManager := &cron.Manager{
		Tasks: cronTasks,
	}
	app := &App{
		Http:   http,
		Routes: routesRoutes,
		Queue:  queueManager,
		Cron:   cronManager,
		DB:     db,
		Redis:  client,
	}
	return app, nil
}

// BuildCli
func BuildCli(cfg *config.Config) *Cli {
	xredisConfig := cfg.Redis
	redisClientOpt := queue.GetRedisClientOpt(xredisConfig)
	xlogConfig := cfg.Log
	appConfig := cfg.App
	manager := xlog.NewManager(xlogConfig, appConfig)
	logger := queue.NewLogger(manager)
	asynqConfig := queue.GetConfig(logger)
	client := xredis.NewRedis(xredisConfig)
	demoTask := &queue.DemoTask{
		Redis: client,
	}
	tasks := &queue.Tasks{
		DemoTask: demoTask,
	}
	queueManager := &queue.Manager{
		RdsOpt: redisClientOpt,
		Conf:   asynqConfig,
		Tasks:  tasks,
	}
	cronDemoTask := &cron.DemoTask{}
	cronTasks := &cron.Tasks{
		DemoTask: cronDemoTask,
	}
	cronManager := &cron.Manager{
		Tasks: cronTasks,
	}
	xmysqlConfig := cfg.Mysql
	generator := xmysql.NewGenerator(xmysqlConfig, appConfig)
	cli := &Cli{
		Queue:   queueManager,
		Cron:    cronManager,
		GormGen: generator,
	}
	return cli
}
